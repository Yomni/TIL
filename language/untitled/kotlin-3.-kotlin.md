---
description: '고차 함수, 람다식, 객체 지향 프로그래밍 언어 로서의 코틀린의 특성'
---

# \[Kotlin 후려치기\] 3. Kotlin 코틀린과 객체 지향 프로그래밍

## 객체 지향적인 언어로서의 코틀린

### 객체 지향적인 추상화의 특징

* **모든 것은 객체다** : 객체는 그저 설계나 정의에 의해 설정되고 할당된 메모리 블록, 주어진 문제 속에서 논리적인 엔티티를 가지고 이를 프로그램 안에서 객체로 전환한다.
* **객체는 메시지를 보내고 받는 방식으로 통신한다\(객체 관점\)** : 프로그램은 각 객체가 노출한 메소드를 호출한 결과로 각기 다른 동작을 수행하는 객체들의 집합이 된다.
* **객체는 자신만의 메모리를 갖는다\(객체 관점\)** : 다른 객체를 합성함으로써 객체를 생성할 수 있다.
* **모든 객체는 클래스의 인스턴스다\(반드시 객체여야 한다\)**  : 클래스는 타입이 할 수 있는 것을 명시한 청사진으로 생각할 수 있다.
* **클래스는 인스턴스를 위한 공유되는 행위를 갖는다\(프로그램 리스트에서 객체의 형태로\)** : 특정 타입의 객체는 모두 같은 메시지를 받을 수 있다. ; 객체는 같은 메소드를 노출한다.

코틀린은 위 내용을 모두 지원하면서도 OOP 언어의 세 가지 기둥인

* **캡슐화\(encapsulation\)** : 연관된 필드와 메소드 그룹을 객체로 다룬다
* **상속\(inheritance\)** : 이미 존재하는 클래스로부터 새로운 클래스를 생성할 수 있다
* **다형성\(polymorphism\)** : 각 클래스마다 자신의 메소드를 다르게 구현했음에도 각기 다른 클래스를 상호 교환하면서 사용할 수 있다

를 지원한다.

OOP 추상화는 대규모 코드에서 발생할 수 있는 문제를 완화하는데 큰 도움이 된다. OOP 추상화는 다음과 같은 기능들을 제공함으로써 코드를 유연하고 유지하기 쉽게 개선해줄 수 있다.

* **단순성** : 프로그램 객체는 현실을 모델링하므로, 복잡성은 줄이고 프로그램 구조는 단순화 한다.
* **모듈성** : 각 객체의 내부 동작은 시스템의 다른 부분과 분리되어 있다.
* **가변성** : 설계를 올바르게 했다면 객체 내부를 변경해도 프로그램의 다른 부분에 영향을 주지 않는다.
* **확장성** : 객체의 요구사항은 빈번하게 바뀌며, 새로운 객체를 추가하거나 이미 존재하는 객체를 변경하는 방법으로 이러한 요구사항에 빠르게 대응할 수 있다.
* **재활용성** : 객체는 다른 프로그램에서 사용될 수 있다.

### tip\) **OOP의 5원칙\(SOLID\)**

* **S \(SRP : Single Responsibility Principle\)** _한 클래스는 하나의 책임만 가져야 한다_
* **O \(OCP : Open / Closed Principle\)** _확장에는 열려\(Open\) 있으나, 변경에는 닫혀\(Closed\) 있어야 한다._
* **L \(LSP : Liskov's Substitution Principle\)** _프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다._
* **I \(ISP : Interface Segregation Principle\)** _특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다_
* **D \(DIP : Dependency Inversion Principle\)** _추상화에 의존한다. 구체화에 의존하면 안된다_

## 클래스

### 접근 레벨

### 중첩 클래스

### 데이터 클래스

### 열거형 클래스

### 정적 메소드와 컴패니언 오브젝트 

## 인터페이스

## 상속

## 가시성 제어자

## 추상 클래스

## 인터페이스 또는 추상 클래스

## 다형성

## 오버라이딩 규칙

## 상속 대 합성

## 클래스 델리게이션

## 봉인 클래스

## 요약

